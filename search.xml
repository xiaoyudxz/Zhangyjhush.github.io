<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>23种设计模式的Csharp实现</title>
      <link href="/2020/06/09/designpattern/"/>
      <url>/2020/06/09/designpattern/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计模式是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案，文章使用CSharp进行编写。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式指的是<b>确保每个类只有一个实例，并提供一个全局访问点</b><br>在系统中某个对象只需要一个实例的时候，例如操作系统中只能有一个任务管理器,操作文件时,同一时间内只允许一个实例对其操作，这时候就可以使用单例模式。</p><blockquote><p>下表为各种单例实现的比较</p></blockquote><table><thead><tr><th></th><th align="center">线程安全</th><th align="center">并发性能好</th><th align="center">可延迟加载</th><th align="center">序列化/反序列化安全</th></tr></thead><tbody><tr><td>饿汉式</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td><td align="center">$\times$</td></tr><tr><td>懒汉式</td><td align="center">$\checkmark$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>双重锁定</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>静态内部类</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>枚举</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式的单例实现<code>instance</code>在类被加载的时候初始化</p><pre class="line-numbers language-CSharp"><code class="language-CSharp">internal class Singleton1{    private static Singleton1 instance = new Singleton1();    internal static Singleton1 Instance    {        get        {            return instance;        }    }    private Singleton1()    {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式的单例实现为了保障线程安全，我们可以使用<code>lock</code>对<code>locker</code>进行加锁。</p><pre class="line-numbers language-CSharp"><code class="language-CSharp">internal class Singleton2{   private static Singleton2 instance = null;   private static readonly object locker = new object();   internal static Singleton2 Instance   {       get       {           lock(locker)           {               if (instance == null)                   instance = new Singleton2();           }           return instance;       }   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双重锁定"><a href="#双重锁定" class="headerlink" title="双重锁定"></a>双重锁定</h3><p>在懒汉式的实现中，每次去获取<code>instance</code>都需要对<code>locker</code>进行加锁，造成了资源的浪费，如果在加锁前对<code>instance</code>进行判断，如果其已经实例化，我们就不需要再进行任何加锁操作了。</p><pre class="line-numbers language-CSharp"><code class="language-CSharp">internal class Singleton3{    private static Singleton3 instance = null;    private static readonly object locker = new object();    internal static Singleton3 Instance    {        get        {            if (instance == null)            {                lock (locker)                {                    if (instance == null)                    {                        instance = new Singleton3();                    }                }            }            return instance;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>第一次加载Singleton类时不会初始化instance，在获取Instance时将会初始化instance<br>这种方法是线程安全的。</p><pre class="line-numbers language-CSharp"><code class="language-CSharp">internal class Singleton4{    public static Singleton4 Instance    {        get        {            return SingletonHolder.instance;        }    }    private Singleton4()    {    }    private static class SingletonHolder    {        internal static Singleton4 instance = new Singleton4();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在<code>Extensions</code>中可以为<code>INSTANCE</code>添加方法，默认是线程安全的。</p><pre class="line-numbers language-CSharp"><code class="language-CSharp">public enum SingletonEnum{    INSTANCE}public static class Extensions{    public static void DoSomething(this SingletonEnum singletonEnum)    {        Console.WriteLine("test");    }}/// <summary>/// 测试/// </summary>static void Main(string[] args){   SingletonEnum singletonEnum = SingletonEnum.INSTANCE;   singletonEnum.DoSomething();   Console.ReadLine();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>类似于<code>C++</code>的拷贝构造函数，但对于拷贝构造函数而言，生成的新对象只能是类本身。也就是说对于一个指向派生类的基类指针，我们无法依靠拷贝构造函数去克隆一个派生类对象。</p><pre class="line-numbers language-CSharp"><code class="language-CSharp">internal abstract class Cloneable{    public int ID { get; set; }    public Cloneable(int id = 0)    {        ID = id;    }    public abstract Cloneable Clone();}internal class Prototype : Cloneable{    public string Name { get; set; }    public Prototype(int id = 0, string name = "zhangyjhush")        :base(id)    {        Name = name;    }    public override Cloneable Clone()    {        Prototype temp = new Prototype(ID, Name);        return temp;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> CSharp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
